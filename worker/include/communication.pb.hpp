// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: controller/pkg/proto/communication/communication.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_controller_2fpkg_2fproto_2fcommunication_2fcommunication_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_controller_2fpkg_2fproto_2fcommunication_2fcommunication_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4024000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4024004 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_controller_2fpkg_2fproto_2fcommunication_2fcommunication_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_controller_2fpkg_2fproto_2fcommunication_2fcommunication_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_controller_2fpkg_2fproto_2fcommunication_2fcommunication_2eproto;
class ControlMsg;
struct ControlMsgDefaultTypeInternal;
extern ControlMsgDefaultTypeInternal _ControlMsg_default_instance_;
class PulseResponse;
struct PulseResponseDefaultTypeInternal;
extern PulseResponseDefaultTypeInternal _PulseResponse_default_instance_;
class WorkerPulse;
struct WorkerPulseDefaultTypeInternal;
extern WorkerPulseDefaultTypeInternal _WorkerPulse_default_instance_;
class WorkerResponse;
struct WorkerResponseDefaultTypeInternal;
extern WorkerResponseDefaultTypeInternal _WorkerResponse_default_instance_;
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

enum PulseType : int {
  PULSE_INVALD = 0,
  PULSE_OK = 1,
  PULSE_REGISTER = 2,
  PULSE_FETCH_ME = 3,
  PULSE_SHUTDOWN = 4,
  PulseType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  PulseType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool PulseType_IsValid(int value);
constexpr PulseType PulseType_MIN = static_cast<PulseType>(0);
constexpr PulseType PulseType_MAX = static_cast<PulseType>(4);
constexpr int PulseType_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
PulseType_descriptor();
template <typename T>
const std::string& PulseType_Name(T value) {
  static_assert(std::is_same<T, PulseType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to PulseType_Name().");
  return PulseType_Name(static_cast<PulseType>(value));
}
template <>
inline const std::string& PulseType_Name(PulseType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<PulseType_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool PulseType_Parse(absl::string_view name, PulseType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PulseType>(
      PulseType_descriptor(), name, value);
}
enum ControllerError : int {
  CTRL_ERR_INVALID = 0,
  CTRL_ERR_OK = 1,
  CTRL_ERR_UNKNOWN_TYPE = 2,
  CTRL_ERR_UNKNOWN_ID = 3,
  CTRL_ERR_FAILED = 4,
  ControllerError_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ControllerError_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ControllerError_IsValid(int value);
constexpr ControllerError ControllerError_MIN = static_cast<ControllerError>(0);
constexpr ControllerError ControllerError_MAX = static_cast<ControllerError>(4);
constexpr int ControllerError_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
ControllerError_descriptor();
template <typename T>
const std::string& ControllerError_Name(T value) {
  static_assert(std::is_same<T, ControllerError>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ControllerError_Name().");
  return ControllerError_Name(static_cast<ControllerError>(value));
}
template <>
inline const std::string& ControllerError_Name(ControllerError value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ControllerError_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool ControllerError_Parse(absl::string_view name, ControllerError* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ControllerError>(
      ControllerError_descriptor(), name, value);
}
enum ControlType : int {
  CTRL_INVALID = 0,
  CTRL_RESTART = 1,
  CTRL_FETCH = 2,
  CTRL_SET_TASK = 3,
  CTRL_GET_STATUS = 4,
  ControlType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ControlType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ControlType_IsValid(int value);
constexpr ControlType ControlType_MIN = static_cast<ControlType>(0);
constexpr ControlType ControlType_MAX = static_cast<ControlType>(4);
constexpr int ControlType_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
ControlType_descriptor();
template <typename T>
const std::string& ControlType_Name(T value) {
  static_assert(std::is_same<T, ControlType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ControlType_Name().");
  return ControlType_Name(static_cast<ControlType>(value));
}
template <>
inline const std::string& ControlType_Name(ControlType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ControlType_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool ControlType_Parse(absl::string_view name, ControlType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ControlType>(
      ControlType_descriptor(), name, value);
}
enum WorkerError : int {
  WORKER_ERROR_INVALID = 0,
  WORKER_ERR_OK = 1,
  WORKER_ERR_NO_FETCH = 2,
  WORKER_ERR_BUSY = 3,
  WORKER_ERR_TASK_FAILED = 4,
  WORKER_ERR_FAILED = 5,
  WorkerError_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  WorkerError_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool WorkerError_IsValid(int value);
constexpr WorkerError WorkerError_MIN = static_cast<WorkerError>(0);
constexpr WorkerError WorkerError_MAX = static_cast<WorkerError>(5);
constexpr int WorkerError_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor*
WorkerError_descriptor();
template <typename T>
const std::string& WorkerError_Name(T value) {
  static_assert(std::is_same<T, WorkerError>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to WorkerError_Name().");
  return WorkerError_Name(static_cast<WorkerError>(value));
}
template <>
inline const std::string& WorkerError_Name(WorkerError value) {
  return ::google::protobuf::internal::NameOfDenseEnum<WorkerError_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool WorkerError_Parse(absl::string_view name, WorkerError* value) {
  return ::google::protobuf::internal::ParseNamedEnum<WorkerError>(
      WorkerError_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class WorkerPulse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:WorkerPulse) */ {
 public:
  inline WorkerPulse() : WorkerPulse(nullptr) {}
  ~WorkerPulse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR WorkerPulse(::google::protobuf::internal::ConstantInitialized);

  WorkerPulse(const WorkerPulse& from);
  WorkerPulse(WorkerPulse&& from) noexcept
    : WorkerPulse() {
    *this = ::std::move(from);
  }

  inline WorkerPulse& operator=(const WorkerPulse& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkerPulse& operator=(WorkerPulse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkerPulse& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorkerPulse* internal_default_instance() {
    return reinterpret_cast<const WorkerPulse*>(
               &_WorkerPulse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(WorkerPulse& a, WorkerPulse& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkerPulse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkerPulse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorkerPulse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WorkerPulse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WorkerPulse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const WorkerPulse& from) {
    WorkerPulse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkerPulse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "WorkerPulse";
  }
  protected:
  explicit WorkerPulse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWorkerIdFieldNumber = 2,
    kTaskIdFieldNumber = 3,
    kNextPulseFieldNumber = 4,
    kTypeFieldNumber = 1,
  };
  // uint64 worker_id = 2;
  void clear_worker_id() ;
  ::uint64_t worker_id() const;
  void set_worker_id(::uint64_t value);

  private:
  ::uint64_t _internal_worker_id() const;
  void _internal_set_worker_id(::uint64_t value);

  public:
  // uint64 task_id = 3;
  void clear_task_id() ;
  ::uint64_t task_id() const;
  void set_task_id(::uint64_t value);

  private:
  ::uint64_t _internal_task_id() const;
  void _internal_set_task_id(::uint64_t value);

  public:
  // uint64 next_pulse = 4;
  void clear_next_pulse() ;
  ::uint64_t next_pulse() const;
  void set_next_pulse(::uint64_t value);

  private:
  ::uint64_t _internal_next_pulse() const;
  void _internal_set_next_pulse(::uint64_t value);

  public:
  // .PulseType type = 1;
  void clear_type() ;
  ::PulseType type() const;
  void set_type(::PulseType value);

  private:
  ::PulseType _internal_type() const;
  void _internal_set_type(::PulseType value);

  public:
  // @@protoc_insertion_point(class_scope:WorkerPulse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint64_t worker_id_;
    ::uint64_t task_id_;
    ::uint64_t next_pulse_;
    int type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_controller_2fpkg_2fproto_2fcommunication_2fcommunication_2eproto;
};// -------------------------------------------------------------------

class PulseResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PulseResponse) */ {
 public:
  inline PulseResponse() : PulseResponse(nullptr) {}
  ~PulseResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PulseResponse(::google::protobuf::internal::ConstantInitialized);

  PulseResponse(const PulseResponse& from);
  PulseResponse(PulseResponse&& from) noexcept
    : PulseResponse() {
    *this = ::std::move(from);
  }

  inline PulseResponse& operator=(const PulseResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PulseResponse& operator=(PulseResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PulseResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PulseResponse* internal_default_instance() {
    return reinterpret_cast<const PulseResponse*>(
               &_PulseResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(PulseResponse& a, PulseResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PulseResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PulseResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PulseResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PulseResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PulseResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PulseResponse& from) {
    PulseResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PulseResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "PulseResponse";
  }
  protected:
  explicit PulseResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWorkerIdFieldNumber = 2,
    kErrorFieldNumber = 1,
  };
  // uint64 worker_id = 2;
  void clear_worker_id() ;
  ::uint64_t worker_id() const;
  void set_worker_id(::uint64_t value);

  private:
  ::uint64_t _internal_worker_id() const;
  void _internal_set_worker_id(::uint64_t value);

  public:
  // .ControllerError error = 1;
  void clear_error() ;
  ::ControllerError error() const;
  void set_error(::ControllerError value);

  private:
  ::ControllerError _internal_error() const;
  void _internal_set_error(::ControllerError value);

  public:
  // @@protoc_insertion_point(class_scope:PulseResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint64_t worker_id_;
    int error_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_controller_2fpkg_2fproto_2fcommunication_2fcommunication_2eproto;
};// -------------------------------------------------------------------

class ControlMsg final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ControlMsg) */ {
 public:
  inline ControlMsg() : ControlMsg(nullptr) {}
  ~ControlMsg() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ControlMsg(::google::protobuf::internal::ConstantInitialized);

  ControlMsg(const ControlMsg& from);
  ControlMsg(ControlMsg&& from) noexcept
    : ControlMsg() {
    *this = ::std::move(from);
  }

  inline ControlMsg& operator=(const ControlMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControlMsg& operator=(ControlMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControlMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const ControlMsg* internal_default_instance() {
    return reinterpret_cast<const ControlMsg*>(
               &_ControlMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ControlMsg& a, ControlMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(ControlMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControlMsg* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControlMsg* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ControlMsg>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ControlMsg& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ControlMsg& from) {
    ControlMsg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControlMsg* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ControlMsg";
  }
  protected:
  explicit ControlMsg(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExtraSizeFieldNumber = 2,
    kTaskIdFieldNumber = 3,
    kTypeFieldNumber = 1,
  };
  // uint64 extra_size = 2;
  void clear_extra_size() ;
  ::uint64_t extra_size() const;
  void set_extra_size(::uint64_t value);

  private:
  ::uint64_t _internal_extra_size() const;
  void _internal_set_extra_size(::uint64_t value);

  public:
  // uint64 task_id = 3;
  void clear_task_id() ;
  ::uint64_t task_id() const;
  void set_task_id(::uint64_t value);

  private:
  ::uint64_t _internal_task_id() const;
  void _internal_set_task_id(::uint64_t value);

  public:
  // .ControlType type = 1;
  void clear_type() ;
  ::ControlType type() const;
  void set_type(::ControlType value);

  private:
  ::ControlType _internal_type() const;
  void _internal_set_type(::ControlType value);

  public:
  // @@protoc_insertion_point(class_scope:ControlMsg)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint64_t extra_size_;
    ::uint64_t task_id_;
    int type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_controller_2fpkg_2fproto_2fcommunication_2fcommunication_2eproto;
};// -------------------------------------------------------------------

class WorkerResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:WorkerResponse) */ {
 public:
  inline WorkerResponse() : WorkerResponse(nullptr) {}
  ~WorkerResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR WorkerResponse(::google::protobuf::internal::ConstantInitialized);

  WorkerResponse(const WorkerResponse& from);
  WorkerResponse(WorkerResponse&& from) noexcept
    : WorkerResponse() {
    *this = ::std::move(from);
  }

  inline WorkerResponse& operator=(const WorkerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkerResponse& operator=(WorkerResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkerResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorkerResponse* internal_default_instance() {
    return reinterpret_cast<const WorkerResponse*>(
               &_WorkerResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(WorkerResponse& a, WorkerResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkerResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkerResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorkerResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WorkerResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WorkerResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const WorkerResponse& from) {
    WorkerResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkerResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "WorkerResponse";
  }
  protected:
  explicit WorkerResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskIdFieldNumber = 2,
    kExtraSizeFieldNumber = 3,
    kErrorFieldNumber = 1,
  };
  // uint64 task_id = 2;
  void clear_task_id() ;
  ::uint64_t task_id() const;
  void set_task_id(::uint64_t value);

  private:
  ::uint64_t _internal_task_id() const;
  void _internal_set_task_id(::uint64_t value);

  public:
  // uint64 extra_size = 3;
  void clear_extra_size() ;
  ::uint64_t extra_size() const;
  void set_extra_size(::uint64_t value);

  private:
  ::uint64_t _internal_extra_size() const;
  void _internal_set_extra_size(::uint64_t value);

  public:
  // .WorkerError error = 1;
  void clear_error() ;
  ::WorkerError error() const;
  void set_error(::WorkerError value);

  private:
  ::WorkerError _internal_error() const;
  void _internal_set_error(::WorkerError value);

  public:
  // @@protoc_insertion_point(class_scope:WorkerResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint64_t task_id_;
    ::uint64_t extra_size_;
    int error_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_controller_2fpkg_2fproto_2fcommunication_2fcommunication_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// WorkerPulse

// .PulseType type = 1;
inline void WorkerPulse::clear_type() {
  _impl_.type_ = 0;
}
inline ::PulseType WorkerPulse::type() const {
  // @@protoc_insertion_point(field_get:WorkerPulse.type)
  return _internal_type();
}
inline void WorkerPulse::set_type(::PulseType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:WorkerPulse.type)
}
inline ::PulseType WorkerPulse::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::PulseType>(_impl_.type_);
}
inline void WorkerPulse::_internal_set_type(::PulseType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// uint64 worker_id = 2;
inline void WorkerPulse::clear_worker_id() {
  _impl_.worker_id_ = ::uint64_t{0u};
}
inline ::uint64_t WorkerPulse::worker_id() const {
  // @@protoc_insertion_point(field_get:WorkerPulse.worker_id)
  return _internal_worker_id();
}
inline void WorkerPulse::set_worker_id(::uint64_t value) {
  _internal_set_worker_id(value);
  // @@protoc_insertion_point(field_set:WorkerPulse.worker_id)
}
inline ::uint64_t WorkerPulse::_internal_worker_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.worker_id_;
}
inline void WorkerPulse::_internal_set_worker_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.worker_id_ = value;
}

// uint64 task_id = 3;
inline void WorkerPulse::clear_task_id() {
  _impl_.task_id_ = ::uint64_t{0u};
}
inline ::uint64_t WorkerPulse::task_id() const {
  // @@protoc_insertion_point(field_get:WorkerPulse.task_id)
  return _internal_task_id();
}
inline void WorkerPulse::set_task_id(::uint64_t value) {
  _internal_set_task_id(value);
  // @@protoc_insertion_point(field_set:WorkerPulse.task_id)
}
inline ::uint64_t WorkerPulse::_internal_task_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.task_id_;
}
inline void WorkerPulse::_internal_set_task_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.task_id_ = value;
}

// uint64 next_pulse = 4;
inline void WorkerPulse::clear_next_pulse() {
  _impl_.next_pulse_ = ::uint64_t{0u};
}
inline ::uint64_t WorkerPulse::next_pulse() const {
  // @@protoc_insertion_point(field_get:WorkerPulse.next_pulse)
  return _internal_next_pulse();
}
inline void WorkerPulse::set_next_pulse(::uint64_t value) {
  _internal_set_next_pulse(value);
  // @@protoc_insertion_point(field_set:WorkerPulse.next_pulse)
}
inline ::uint64_t WorkerPulse::_internal_next_pulse() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.next_pulse_;
}
inline void WorkerPulse::_internal_set_next_pulse(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.next_pulse_ = value;
}

// -------------------------------------------------------------------

// PulseResponse

// .ControllerError error = 1;
inline void PulseResponse::clear_error() {
  _impl_.error_ = 0;
}
inline ::ControllerError PulseResponse::error() const {
  // @@protoc_insertion_point(field_get:PulseResponse.error)
  return _internal_error();
}
inline void PulseResponse::set_error(::ControllerError value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:PulseResponse.error)
}
inline ::ControllerError PulseResponse::_internal_error() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::ControllerError>(_impl_.error_);
}
inline void PulseResponse::_internal_set_error(::ControllerError value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.error_ = value;
}

// uint64 worker_id = 2;
inline void PulseResponse::clear_worker_id() {
  _impl_.worker_id_ = ::uint64_t{0u};
}
inline ::uint64_t PulseResponse::worker_id() const {
  // @@protoc_insertion_point(field_get:PulseResponse.worker_id)
  return _internal_worker_id();
}
inline void PulseResponse::set_worker_id(::uint64_t value) {
  _internal_set_worker_id(value);
  // @@protoc_insertion_point(field_set:PulseResponse.worker_id)
}
inline ::uint64_t PulseResponse::_internal_worker_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.worker_id_;
}
inline void PulseResponse::_internal_set_worker_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.worker_id_ = value;
}

// -------------------------------------------------------------------

// ControlMsg

// .ControlType type = 1;
inline void ControlMsg::clear_type() {
  _impl_.type_ = 0;
}
inline ::ControlType ControlMsg::type() const {
  // @@protoc_insertion_point(field_get:ControlMsg.type)
  return _internal_type();
}
inline void ControlMsg::set_type(::ControlType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:ControlMsg.type)
}
inline ::ControlType ControlMsg::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::ControlType>(_impl_.type_);
}
inline void ControlMsg::_internal_set_type(::ControlType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// uint64 extra_size = 2;
inline void ControlMsg::clear_extra_size() {
  _impl_.extra_size_ = ::uint64_t{0u};
}
inline ::uint64_t ControlMsg::extra_size() const {
  // @@protoc_insertion_point(field_get:ControlMsg.extra_size)
  return _internal_extra_size();
}
inline void ControlMsg::set_extra_size(::uint64_t value) {
  _internal_set_extra_size(value);
  // @@protoc_insertion_point(field_set:ControlMsg.extra_size)
}
inline ::uint64_t ControlMsg::_internal_extra_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.extra_size_;
}
inline void ControlMsg::_internal_set_extra_size(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.extra_size_ = value;
}

// uint64 task_id = 3;
inline void ControlMsg::clear_task_id() {
  _impl_.task_id_ = ::uint64_t{0u};
}
inline ::uint64_t ControlMsg::task_id() const {
  // @@protoc_insertion_point(field_get:ControlMsg.task_id)
  return _internal_task_id();
}
inline void ControlMsg::set_task_id(::uint64_t value) {
  _internal_set_task_id(value);
  // @@protoc_insertion_point(field_set:ControlMsg.task_id)
}
inline ::uint64_t ControlMsg::_internal_task_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.task_id_;
}
inline void ControlMsg::_internal_set_task_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.task_id_ = value;
}

// -------------------------------------------------------------------

// WorkerResponse

// .WorkerError error = 1;
inline void WorkerResponse::clear_error() {
  _impl_.error_ = 0;
}
inline ::WorkerError WorkerResponse::error() const {
  // @@protoc_insertion_point(field_get:WorkerResponse.error)
  return _internal_error();
}
inline void WorkerResponse::set_error(::WorkerError value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:WorkerResponse.error)
}
inline ::WorkerError WorkerResponse::_internal_error() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::WorkerError>(_impl_.error_);
}
inline void WorkerResponse::_internal_set_error(::WorkerError value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.error_ = value;
}

// uint64 task_id = 2;
inline void WorkerResponse::clear_task_id() {
  _impl_.task_id_ = ::uint64_t{0u};
}
inline ::uint64_t WorkerResponse::task_id() const {
  // @@protoc_insertion_point(field_get:WorkerResponse.task_id)
  return _internal_task_id();
}
inline void WorkerResponse::set_task_id(::uint64_t value) {
  _internal_set_task_id(value);
  // @@protoc_insertion_point(field_set:WorkerResponse.task_id)
}
inline ::uint64_t WorkerResponse::_internal_task_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.task_id_;
}
inline void WorkerResponse::_internal_set_task_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.task_id_ = value;
}

// uint64 extra_size = 3;
inline void WorkerResponse::clear_extra_size() {
  _impl_.extra_size_ = ::uint64_t{0u};
}
inline ::uint64_t WorkerResponse::extra_size() const {
  // @@protoc_insertion_point(field_get:WorkerResponse.extra_size)
  return _internal_extra_size();
}
inline void WorkerResponse::set_extra_size(::uint64_t value) {
  _internal_set_extra_size(value);
  // @@protoc_insertion_point(field_set:WorkerResponse.extra_size)
}
inline ::uint64_t WorkerResponse::_internal_extra_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.extra_size_;
}
inline void WorkerResponse::_internal_set_extra_size(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.extra_size_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::PulseType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::PulseType>() {
  return ::PulseType_descriptor();
}
template <>
struct is_proto_enum<::ControllerError> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::ControllerError>() {
  return ::ControllerError_descriptor();
}
template <>
struct is_proto_enum<::ControlType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::ControlType>() {
  return ::ControlType_descriptor();
}
template <>
struct is_proto_enum<::WorkerError> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::WorkerError>() {
  return ::WorkerError_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_controller_2fpkg_2fproto_2fcommunication_2fcommunication_2eproto_2epb_2eh
